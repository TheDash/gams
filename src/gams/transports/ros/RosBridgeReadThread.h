
#ifndef   _TRANSPORT_ROSBRIDGEREADTHREAD_H_
#define   _TRANSPORT_ROSBRIDGEREADTHREAD_H_

#include <string>

#include "madara/threads/BaseThread.h"
#include "gams/utility/ros/RosParser.h"

// ROS includes
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
#pragma GCC diagnostic ignored "-Wreorder"
#endif

#include "ros/ros.h"
#include "std_msgs/String.h"
#include "topic_tools/shape_shifter.h"

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

namespace gams
{
  namespace transports
  {
    /**
    * A custom read thread generated by gpc.pl
    **/
    class RosBridgeReadThread : public madara::threads::BaseThread
    {
    public:
      /**
       * Default constructor
       **/
      RosBridgeReadThread (
        const std::string & id,
        const madara::transport::TransportSettings & settings,
        madara::transport::BandwidthMonitor & send_monitor,
        madara::transport::BandwidthMonitor & receive_monitor,
        madara::transport::PacketScheduler & packet_scheduler,
        std::vector<std::string> topics,
        std::map<std::string,std::string> topic_map);
      
      /**
       * Destructor
       **/
      virtual ~RosBridgeReadThread ();
      
      /**
        * Initializes thread with MADARA context
        * @param   context   context for querying current program state
        **/
      virtual void init (madara::knowledge::KnowledgeBase & knowledge);

      /**
        * Executes the main thread logic
        **/
      virtual void run (void);

      void messageCallback(const topic_tools::ShapeShifter::ConstPtr& msg,
        const std::string &topic_name );

      unsigned int message_count();

    private:
      /// data plane if we want to access the knowledge base
      madara::knowledge::ThreadSafeContext * context_;
      
      /// the unique id of this agent (probably a host:port pairing)
      const std::string id_;
      
      /// the transport settings being used
      madara::transport::QoSTransportSettings settings_;
      
      /// buffer for sending
      madara::utility::ScopedArray <char> buffer_;

      /// data received rules, defined in Transport settings
      madara::knowledge::CompiledExpression  on_data_received_;
        
      /// monitor the bandwidth used for sending
      madara::transport::BandwidthMonitor & send_monitor_;
      
      /// monitor the bandwidth used by others
      madara::transport::BandwidthMonitor & receive_monitor_;
      
      /// a specialty packet scheduler for experimental drop policies
      madara::transport::PacketScheduler & packet_scheduler_;

      std::vector<ros::Subscriber> subscribers_;

      gams::utility::ros::RosParser * parser_;

      // Enabled topics
      std::vector<std::string> topics_;
      // Topic map
      std::map<std::string,std::string> topic_map_;

      unsigned int message_count_;

    };
  }
} // end namespace threads

#endif // _TRANSPORT_ROSBRIDGEREADTHREAD_H_
